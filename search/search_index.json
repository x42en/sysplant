{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"..:: SysPlant ::.. Your Syscall Factory (feat. Canterlot's Gate) SysPlant is a python generation tool of the currently known syscall hooking methods. It currently supports following gates (aka: iterators): - Hell's Gate : Lookup syscall by first opcodes - Halos's Gate : Lookup syscall by first opcodes and search nearby if first instruction is a JMP - Tartarus' Gate : Lookup syscall by first opcodes and search nearby if first or third instruction is a JMP - FreshyCalls : Lookup syscall by name (start with Nt and not Ntdll), sort addresses to retrieve syscall number - SysWhispers2 : Lookup syscall by name (start with Zw), sort addresses to retrieve syscall number - SysWhispers3 : SysWhispers2 style but introduce direct/indirect/random jump with static offset - Canterlot's Gate ! :unicorn: :rainbow: (from an initial idea of MDSEC article ) but who was missing a pony name : Lookup syscall using Runtime Exception Table (sorted by syscall number) and detect offset to syscall instruction for random jumps. - Custom Allows you to choose an iterator and a syscall stub method (direct / indirect / random) which describe the way your NtFunctions will be effectively called. :warning: DISCLAIMER Please only use this tool on systems you have permission to access. Usage is restricted to Pentesting or Education only. All credits are based on my own research, please feel free to claim any method if I made mistakes... Introduction This personal project aims to be a simple tool to better understand & generate different syscall retrieval methods, and being able to play with direct / indirect syscall stub. The first goal was to get my hands into NIM and then it overflow :wink: ... SysPlant has been developped for Linux users, some stuff might be broken within Windows or Mac. PR are welcome if you found anything that does not work as expected. What is iterator option ? Sysplant is based on existing mechanisms for syscall number and addresses retrieval. I do not claim any of their discovery, I just harmonize all this methods in a single tool to be able to generate them easily using templates. These mechanisms are called iterator , if you look at the code you'll probably understand why :wink: If you want to go further in the explanations of what is a syscall ? you should check @Alice Climent blogpost about syscalls techniques What is method option ? Once your iterator has been choosen you can then specify a method option based on the existing way to call syscalls. All the iterator are supported which let you select whatever you want as a final syscall stub. Direct: the syscall is made directly in the Sysplant ASM call. You only need the syscall number but AV/EDR might see you... Indirect: the Sysplant ASM call jump to the begining of Ntdll stub. You only need syscall address and no longer call syscall in your code but AV/EDR might hook these functions Random: the Sysplant ASM call jump to a random syscall instruction of Ntdll stubs. You need the syscall number and 1 syscall instruction address. You then no longer call syscall in your code and can avoid hooked functions. Documentation I've tried to keep an up to date documentation, so please READ THE DOC . You will find there many information about the tool's usages and a complete description of the classes and methods. Some specifics usages are described: - Sysplant as a CLI tool - Sysplant as a Python's module Credits Massive shout-out to these useful projects that helps me during this journey, or individuals for their reviews - @alice blogpost about syscalls techniques - @redops blogpost about direct vs indirect syscalls - @Jackson_T & @modexpblog for Syswhispers2 - @klezvirus for syswhispers3 :construction: TODO This project is really in WIP state... Some PR & reviews are more than welcome :tada: ! - [x] Add internal names randomization - [x] Setup documentation - [x] Setup tests - [ ] Add x86 support - [ ] Add WoW64 support - [x] Setup C templates - [ ] Setup Go? / CPP? / C#? / Rust? / Whatever templates License This project is licensed under the GPLv3 License , for individuals only. If you want to integrate this work in your commercial project please contact me through 0x42en[at]gmail.com","title":"Home"},{"location":"#introduction","text":"This personal project aims to be a simple tool to better understand & generate different syscall retrieval methods, and being able to play with direct / indirect syscall stub. The first goal was to get my hands into NIM and then it overflow :wink: ... SysPlant has been developped for Linux users, some stuff might be broken within Windows or Mac. PR are welcome if you found anything that does not work as expected.","title":"Introduction"},{"location":"#what-is-iterator-option","text":"Sysplant is based on existing mechanisms for syscall number and addresses retrieval. I do not claim any of their discovery, I just harmonize all this methods in a single tool to be able to generate them easily using templates. These mechanisms are called iterator , if you look at the code you'll probably understand why :wink: If you want to go further in the explanations of what is a syscall ? you should check @Alice Climent blogpost about syscalls techniques","title":"What is iterator option ?"},{"location":"#what-is-method-option","text":"Once your iterator has been choosen you can then specify a method option based on the existing way to call syscalls. All the iterator are supported which let you select whatever you want as a final syscall stub. Direct: the syscall is made directly in the Sysplant ASM call. You only need the syscall number but AV/EDR might see you... Indirect: the Sysplant ASM call jump to the begining of Ntdll stub. You only need syscall address and no longer call syscall in your code but AV/EDR might hook these functions Random: the Sysplant ASM call jump to a random syscall instruction of Ntdll stubs. You need the syscall number and 1 syscall instruction address. You then no longer call syscall in your code and can avoid hooked functions.","title":"What is method option ?"},{"location":"#documentation","text":"I've tried to keep an up to date documentation, so please READ THE DOC . You will find there many information about the tool's usages and a complete description of the classes and methods. Some specifics usages are described: - Sysplant as a CLI tool - Sysplant as a Python's module","title":"Documentation"},{"location":"#credits","text":"Massive shout-out to these useful projects that helps me during this journey, or individuals for their reviews - @alice blogpost about syscalls techniques - @redops blogpost about direct vs indirect syscalls - @Jackson_T & @modexpblog for Syswhispers2 - @klezvirus for syswhispers3","title":"Credits"},{"location":"#construction-todo","text":"This project is really in WIP state... Some PR & reviews are more than welcome :tada: ! - [x] Add internal names randomization - [x] Setup documentation - [x] Setup tests - [ ] Add x86 support - [ ] Add WoW64 support - [x] Setup C templates - [ ] Setup Go? / CPP? / C#? / Rust? / Whatever templates","title":":construction: TODO"},{"location":"#license","text":"This project is licensed under the GPLv3 License , for individuals only. If you want to integrate this work in your commercial project please contact me through 0x42en[at]gmail.com","title":"License"},{"location":"contribute/code_rules/","text":"The Black code style Code style Black aims for consistency, generality, readability and reducing git diffs. Similar language constructs are formatted with similar rules. Style configuration options are deliberately limited and rarely added. Previous formatting is taken into account as little as possible, with rare exceptions like the magic trailing comma. The coding style used by Black can be viewed as a strict subset of PEP 8. Black reformats entire files in place. It doesn't reformat lines that end with # fmt: skip or blocks that start with # fmt: off and end with # fmt: on . # fmt: on/off must be on the same level of indentation and in the same block, meaning no unindents beyond the initial indentation level between them. It also recognizes YAPF 's block comments to the same effect, as a courtesy for straddling code. The rest of this document describes the current formatting style. If you're interested in trying out where the style is heading, see future style and try running black --preview . How Black wraps lines Black ignores previous formatting and applies uniform horizontal and vertical whitespace to your code. The rules for horizontal whitespace can be summarized as: do whatever makes pycodestyle happy. As for vertical whitespace, Black tries to render one full expression or simple statement per line. If this fits the allotted line length, great. # in: j = [1, 2, 3 ] # out: j = [1, 2, 3] If not, Black will look at the contents of the first outer matching brackets and put that in a separate indented line. # in: ImportantClass.important_method(exc, limit, lookup_lines, capture_locals, extra_argument) # out: ImportantClass.important_method( exc, limit, lookup_lines, capture_locals, extra_argument ) If that still doesn't fit the bill, it will decompose the internal expression further using the same rule, indenting matching brackets every time. If the contents of the matching brackets pair are comma-separated (like an argument list, or a dict literal, and so on) then Black will first try to keep them on the same line with the matching brackets. If that doesn't work, it will put all of them in separate lines. # in: def very_important_function(template: str, *variables, file: os.PathLike, engine: str, header: bool = True, debug: bool = False): \"\"\"Applies `variables` to the `template` and writes to `file`.\"\"\" with open(file, 'w') as f: ... # out: def very_important_function( template: str, *variables, file: os.PathLike, engine: str, header: bool = True, debug: bool = False, ): \"\"\"Applies `variables` to the `template` and writes to `file`.\"\"\" with open(file, \"w\") as f: ... If a data structure literal (tuple, list, set, dict) or a line of \"from\" imports cannot fit in the allotted length, it's always split into one element per line. This minimizes diffs as well as enables readers of code to find which commit introduced a particular entry. This also makes Black compatible with isort with the ready-made black profile or manual configuration. You might have noticed that closing brackets are always dedented and that a trailing comma is always added. Such formatting produces smaller diffs; when you add or remove an element, it's always just one line. Also, having the closing bracket dedented provides a clear delimiter between two distinct sections of the code that otherwise share the same indentation level (like the arguments list and the docstring in the example above). (labels/why-no-backslashes)= Black prefers parentheses over backslashes, and will remove backslashes if found. # in: if some_short_rule1 \\ and some_short_rule2: ... # out: if some_short_rule1 and some_short_rule2: ... # in: if some_long_rule1 \\ and some_long_rule2: ... # out: if ( some_long_rule1 and some_long_rule2 ): ... Backslashes and multiline strings are one of the two places in the Python grammar that break significant indentation. You never need backslashes, they are used to force the grammar to accept breaks that would otherwise be parse errors. That makes them confusing to look at and brittle to modify. This is why Black always gets rid of them. If you're reaching for backslashes, that's a clear signal that you can do better if you slightly refactor your code. I hope some of the examples above show you that there are many ways in which you can do it. (labels/line-length)= Line length You probably noticed the peculiar default line length. Black defaults to 88 characters per line, which happens to be 10% over 80. This number was found to produce significantly shorter files than sticking with 80 (the most popular), or even 79 (used by the standard library). In general, 90-ish seems like the wise choice . If you're paid by the line of code you write, you can pass --line-length with a lower number. Black will try to respect that. However, sometimes it won't be able to without breaking other rules. In those rare cases, auto-formatted code will exceed your allotted limit. You can also increase it, but remember that people with sight disabilities find it harder to work with line lengths exceeding 100 characters. It also adversely affects side-by-side diff review on typical screen resolutions. Long lines also make it harder to present code neatly in documentation or talk slides. Flake8 If you use Flake8, you have a few options: Recommended is using Bugbear and enabling its B950 check instead of using Flake8's E501, because it aligns with Black's 10% rule. Install Bugbear and use the following config: ini [flake8] max-line-length = 80 ... select = C,E,F,W,B,B950 extend-ignore = E203, E501 The rationale for E950 is explained in Bugbear's documentation . For a minimally compatible config: ini [flake8] max-line-length = 88 extend-ignore = E203 An explanation of why E203 is disabled can be found in the Slices section of this page. Empty lines Black avoids spurious vertical whitespace. This is in the spirit of PEP 8 which says that in-function vertical whitespace should only be used sparingly. Black will allow single empty lines inside functions, and single and double empty lines on module level left by the original editors, except when they're within parenthesized expressions. Since such expressions are always reformatted to fit minimal space, this whitespace is lost. The other exception is that it will remove any empty lines immediately following a statement that introduces a new indentation level. # in: def foo(): print(\"All the newlines above me should be deleted!\") if condition: print(\"No newline above me!\") print(\"There is a newline above me, and that's OK!\") class Point: x: int y: int # out: def foo(): print(\"All the newlines above me should be deleted!\") if condition: print(\"No newline above me!\") print(\"There is a newline above me, and that's OK!\") class Point: x: int y: int It will also insert proper spacing before and after function definitions. It's one line before and after inner functions and two lines before and after module-level functions and classes. Black will not put empty lines between function/class definitions and standalone comments that immediately precede the given function/class. Black will enforce single empty lines between a class-level docstring and the first following field or method. This conforms to PEP 257 . Black won't insert empty lines after function docstrings unless that empty line is required due to an inner function starting immediately after. Comments Black does not format comment contents, but it enforces two spaces between code and a comment on the same line, and a space before the comment text begins. Some types of comments that require specific spacing rules are respected: doc comments ( #: comment ), section comments with long runs of hashes, and Spyder cells. Non-breaking spaces after hashes are also preserved. Comments may sometimes be moved because of formatting changes, which can break tools that assign special meaning to them. See AST before and after formatting for more discussion. Trailing commas Black will add trailing commas to expressions that are split by comma where each element is on its own line. This includes function signatures. One exception to adding trailing commas is function signatures containing * , *args , or **kwargs . In this case a trailing comma is only safe to use on Python 3.6. Black will detect if your file is already 3.6+ only and use trailing commas in this situation. If you wonder how it knows, it looks for f-strings and existing use of trailing commas in function signatures that have stars in them. In other words, if you'd like a trailing comma in this situation and Black didn't recognize it was safe to do so, put it there manually and Black will keep it. A pre-existing trailing comma informs Black to always explode contents of the current bracket pair into one item per line. Read more about this in the Pragmatism section below. (labels/strings)= Strings Black prefers double quotes ( \" and \"\"\" ) over single quotes ( ' and ''' ). It will replace the latter with the former as long as it does not result in more backslash escapes than before. Black also standardizes string prefixes. Prefix characters are made lowercase with the exception of capital \"R\" prefixes , unicode literal markers ( u ) are removed because they are meaningless in Python 3, and in the case of multiple characters \"r\" is put first as in spoken language: \"raw f-string\". The main reason to standardize on a single form of quotes is aesthetics. Having one kind of quotes everywhere reduces reader distraction. It will also enable a future version of Black to merge consecutive string literals that ended up on the same line (see #26 for details). Why settle on double quotes? They anticipate apostrophes in English text. They match the docstring standard described in PEP 257 . An empty string in double quotes ( \"\" ) is impossible to confuse with a one double-quote regardless of fonts and syntax highlighting used. On top of this, double quotes for strings are consistent with C which Python interacts a lot with. On certain keyboard layouts like US English, typing single quotes is a bit easier than double quotes. The latter requires use of the Shift key. My recommendation here is to keep using whatever is faster to type and let Black handle the transformation. If you are adopting Black in a large project with pre-existing string conventions (like the popular \"single quotes for data, double quotes for human-readable strings\" ), you can pass --skip-string-normalization on the command line. This is meant as an adoption helper, avoid using this for new projects. Black also processes docstrings. Firstly the indentation of docstrings is corrected for both quotations and the text within, although relative indentation in the text is preserved. Superfluous trailing whitespace on each line and unnecessary new lines at the end of the docstring are removed. All leading tabs are converted to spaces, but tabs inside text are preserved. Whitespace leading and trailing one-line docstrings is removed. Numeric literals Black standardizes most numeric literals to use lowercase letters for the syntactic parts and uppercase letters for the digits themselves: 0xAB instead of 0XAB and 1e10 instead of 1E10 . Line breaks & binary operators Black will break a line before a binary operator when splitting a block of code over multiple lines. This is so that Black is compliant with the recent changes in the PEP 8 style guide, which emphasizes that this approach improves readability. Almost all operators will be surrounded by single spaces, the only exceptions are unary operators ( + , - , and ~ ), and power operators when both operands are simple. For powers, an operand is considered simple if it's only a NAME, numeric CONSTANT, or attribute access (chained attribute access is allowed), with or without a preceding unary operator. # For example, these won't be surrounded by whitespace a = x**y b = config.base**5.2 c = config.base**runtime.config.exponent d = 2**5 e = 2**~5 # ... but these will be surrounded by whitespace f = 2 ** get_exponent() g = get_x() ** get_y() h = config['base'] ** 2 Slices PEP 8 recommends to treat : in slices as a binary operator with the lowest priority, and to leave an equal amount of space on either side, except if a parameter is omitted (e.g. ham[1 + 1 :] ). It recommends no spaces around : operators for \"simple expressions\" ( ham[lower:upper] ), and extra space for \"complex expressions\" ( ham[lower : upper + offset] ). Black treats anything more than variable names as \"complex\" ( ham[lower : upper + 1] ). It also states that for extended slices, both : operators have to have the same amount of spacing, except if a parameter is omitted ( ham[1 + 1 ::] ). Black enforces these rules consistently. This behaviour may raise E203 whitespace before ':' warnings in style guide enforcement tools like Flake8. Since E203 is not PEP 8 compliant, you should tell Flake8 to ignore these warnings. Parentheses Some parentheses are optional in the Python grammar. Any expression can be wrapped in a pair of parentheses to form an atom. There are a few interesting cases: if (...): while (...): for (...) in (...): assert (...), (...) from X import (...) assignments like: target = (...) target: type = (...) some, *un, packing = (...) augmented += (...) In those cases, parentheses are removed when the entire statement fits in one line, or if the inner expression doesn't have any delimiters to further split on. If there is only a single delimiter and the expression starts or ends with a bracket, the parentheses can also be successfully omitted since the existing bracket pair will organize the expression neatly anyway. Otherwise, the parentheses are added. Please note that Black does not add or remove any additional nested parentheses that you might want to have for clarity or further code organization. For example those parentheses are not going to be removed: return not (this or that) decision = (maybe.this() and values > 0) or (maybe.that() and values < 0) Call chains Some popular APIs, like ORMs, use call chaining. This API style is known as a fluent interface . Black formats those by treating dots that follow a call or an indexing operation like a very low priority delimiter. It's easier to show the behavior than to explain it. Look at the example: def example(session): result = ( session.query(models.Customer.id) .filter( models.Customer.account_id == account_id, models.Customer.email == email_address, ) .order_by(models.Customer.id.asc()) .all() ) Typing stub files PEP 484 describes the syntax for type hints in Python. One of the use cases for typing is providing type annotations for modules which cannot contain them directly (they might be written in C, or they might be third-party, or their implementation may be overly dynamic, and so on). To solve this, stub files with the .pyi file extension can be used to describe typing information for an external module. Those stub files omit the implementation of classes and functions they describe, instead they only contain the structure of the file (listing globals, functions, and classes with their members). The recommended code style for those files is more terse than PEP 8: prefer ... on the same line as the class/function signature; avoid vertical whitespace between consecutive module-level functions, names, or methods and fields within a single class; use a single blank line between top-level class definitions, or none if the classes are very small. Black enforces the above rules. There are additional guidelines for formatting .pyi file that are not enforced yet but might be in a future version of the formatter: prefer ... over pass ; avoid using string literals in type annotations, stub files support forward references natively (like Python 3.7 code with from __future__ import annotations ); use variable annotations instead of type comments, even for stubs that target older versions of Python. Line endings Black will normalize line endings ( \\n or \\r\\n ) based on the first line ending of the file. Pragmatism Early versions of Black used to be absolutist in some respects. They took after its initial author. This was fine at the time as it made the implementation simpler and there were not many users anyway. Not many edge cases were reported. As a mature tool, Black does make some exceptions to rules it otherwise holds. This section documents what those exceptions are and why this is the case. (labels/magic-trailing-comma)= The magic trailing comma Black in general does not take existing formatting into account. However, there are cases where you put a short collection or function call in your code but you anticipate it will grow in the future. For example: TRANSLATIONS = { \"en_us\": \"English (US)\", \"pl_pl\": \"polski\", } Early versions of Black used to ruthlessly collapse those into one line (it fits!). Now, you can communicate that you don't want that by putting a trailing comma in the collection yourself. When you do, Black will know to always explode your collection into one item per line. How do you make it stop? Just delete that trailing comma and Black will collapse your collection into one line if it fits. If you must, you can recover the behaviour of early versions of Black with the option --skip-magic-trailing-comma / -C . r\"strings\" and R\"strings\" Black normalizes string quotes as well as string prefixes, making them lowercase. One exception to this rule is r-strings. It turns out that the very popular MagicPython syntax highlighter, used by default by (among others) GitHub and Visual Studio Code, differentiates between r-strings and R-strings. The former are syntax highlighted as regular expressions while the latter are treated as true raw strings with no special semantics. (labels/ast-changes)= AST before and after formatting When run with --safe (the default), Black checks that the code before and after is semantically equivalent. This check is done by comparing the AST of the source with the AST of the target. There are three limited cases in which the AST does differ: Black cleans up leading and trailing whitespace of docstrings, re-indenting them if needed. It's been one of the most popular user-reported features for the formatter to fix whitespace issues with docstrings. While the result is technically an AST difference, due to the various possibilities of forming docstrings, all real-world uses of docstrings that we're aware of sanitize indentation and leading/trailing whitespace anyway. Black manages optional parentheses for some statements. In the case of the del statement, presence of wrapping parentheses or lack of thereof changes the resulting AST but is semantically equivalent in the interpreter. Black might move comments around, which includes type comments. Those are part of the AST as of Python 3.8. While the tool implements a number of special cases for those comments, there is no guarantee they will remain where they were in the source. Note that this doesn't change runtime behavior of the source code. To put things in perspective, the code equivalence check is a feature of Black which other formatters don't implement at all. It is of crucial importance to us to ensure code behaves the way it did before it got reformatted. We treat this as a feature and there are no plans to relax this in the future. The exceptions enumerated above stem from either user feedback or implementation details of the tool. In each case we made due diligence to ensure that the AST divergence is of no practical consequence.","title":"The Black code style"},{"location":"contribute/code_rules/#the-black-code-style","text":"","title":"The Black code style"},{"location":"contribute/code_rules/#code-style","text":"Black aims for consistency, generality, readability and reducing git diffs. Similar language constructs are formatted with similar rules. Style configuration options are deliberately limited and rarely added. Previous formatting is taken into account as little as possible, with rare exceptions like the magic trailing comma. The coding style used by Black can be viewed as a strict subset of PEP 8. Black reformats entire files in place. It doesn't reformat lines that end with # fmt: skip or blocks that start with # fmt: off and end with # fmt: on . # fmt: on/off must be on the same level of indentation and in the same block, meaning no unindents beyond the initial indentation level between them. It also recognizes YAPF 's block comments to the same effect, as a courtesy for straddling code. The rest of this document describes the current formatting style. If you're interested in trying out where the style is heading, see future style and try running black --preview .","title":"Code style"},{"location":"contribute/code_rules/#how-black-wraps-lines","text":"Black ignores previous formatting and applies uniform horizontal and vertical whitespace to your code. The rules for horizontal whitespace can be summarized as: do whatever makes pycodestyle happy. As for vertical whitespace, Black tries to render one full expression or simple statement per line. If this fits the allotted line length, great. # in: j = [1, 2, 3 ] # out: j = [1, 2, 3] If not, Black will look at the contents of the first outer matching brackets and put that in a separate indented line. # in: ImportantClass.important_method(exc, limit, lookup_lines, capture_locals, extra_argument) # out: ImportantClass.important_method( exc, limit, lookup_lines, capture_locals, extra_argument ) If that still doesn't fit the bill, it will decompose the internal expression further using the same rule, indenting matching brackets every time. If the contents of the matching brackets pair are comma-separated (like an argument list, or a dict literal, and so on) then Black will first try to keep them on the same line with the matching brackets. If that doesn't work, it will put all of them in separate lines. # in: def very_important_function(template: str, *variables, file: os.PathLike, engine: str, header: bool = True, debug: bool = False): \"\"\"Applies `variables` to the `template` and writes to `file`.\"\"\" with open(file, 'w') as f: ... # out: def very_important_function( template: str, *variables, file: os.PathLike, engine: str, header: bool = True, debug: bool = False, ): \"\"\"Applies `variables` to the `template` and writes to `file`.\"\"\" with open(file, \"w\") as f: ... If a data structure literal (tuple, list, set, dict) or a line of \"from\" imports cannot fit in the allotted length, it's always split into one element per line. This minimizes diffs as well as enables readers of code to find which commit introduced a particular entry. This also makes Black compatible with isort with the ready-made black profile or manual configuration. You might have noticed that closing brackets are always dedented and that a trailing comma is always added. Such formatting produces smaller diffs; when you add or remove an element, it's always just one line. Also, having the closing bracket dedented provides a clear delimiter between two distinct sections of the code that otherwise share the same indentation level (like the arguments list and the docstring in the example above). (labels/why-no-backslashes)= Black prefers parentheses over backslashes, and will remove backslashes if found. # in: if some_short_rule1 \\ and some_short_rule2: ... # out: if some_short_rule1 and some_short_rule2: ... # in: if some_long_rule1 \\ and some_long_rule2: ... # out: if ( some_long_rule1 and some_long_rule2 ): ... Backslashes and multiline strings are one of the two places in the Python grammar that break significant indentation. You never need backslashes, they are used to force the grammar to accept breaks that would otherwise be parse errors. That makes them confusing to look at and brittle to modify. This is why Black always gets rid of them. If you're reaching for backslashes, that's a clear signal that you can do better if you slightly refactor your code. I hope some of the examples above show you that there are many ways in which you can do it. (labels/line-length)=","title":"How Black wraps lines"},{"location":"contribute/code_rules/#line-length","text":"You probably noticed the peculiar default line length. Black defaults to 88 characters per line, which happens to be 10% over 80. This number was found to produce significantly shorter files than sticking with 80 (the most popular), or even 79 (used by the standard library). In general, 90-ish seems like the wise choice . If you're paid by the line of code you write, you can pass --line-length with a lower number. Black will try to respect that. However, sometimes it won't be able to without breaking other rules. In those rare cases, auto-formatted code will exceed your allotted limit. You can also increase it, but remember that people with sight disabilities find it harder to work with line lengths exceeding 100 characters. It also adversely affects side-by-side diff review on typical screen resolutions. Long lines also make it harder to present code neatly in documentation or talk slides.","title":"Line length"},{"location":"contribute/code_rules/#flake8","text":"If you use Flake8, you have a few options: Recommended is using Bugbear and enabling its B950 check instead of using Flake8's E501, because it aligns with Black's 10% rule. Install Bugbear and use the following config: ini [flake8] max-line-length = 80 ... select = C,E,F,W,B,B950 extend-ignore = E203, E501 The rationale for E950 is explained in Bugbear's documentation . For a minimally compatible config: ini [flake8] max-line-length = 88 extend-ignore = E203 An explanation of why E203 is disabled can be found in the Slices section of this page.","title":"Flake8"},{"location":"contribute/code_rules/#empty-lines","text":"Black avoids spurious vertical whitespace. This is in the spirit of PEP 8 which says that in-function vertical whitespace should only be used sparingly. Black will allow single empty lines inside functions, and single and double empty lines on module level left by the original editors, except when they're within parenthesized expressions. Since such expressions are always reformatted to fit minimal space, this whitespace is lost. The other exception is that it will remove any empty lines immediately following a statement that introduces a new indentation level. # in: def foo(): print(\"All the newlines above me should be deleted!\") if condition: print(\"No newline above me!\") print(\"There is a newline above me, and that's OK!\") class Point: x: int y: int # out: def foo(): print(\"All the newlines above me should be deleted!\") if condition: print(\"No newline above me!\") print(\"There is a newline above me, and that's OK!\") class Point: x: int y: int It will also insert proper spacing before and after function definitions. It's one line before and after inner functions and two lines before and after module-level functions and classes. Black will not put empty lines between function/class definitions and standalone comments that immediately precede the given function/class. Black will enforce single empty lines between a class-level docstring and the first following field or method. This conforms to PEP 257 . Black won't insert empty lines after function docstrings unless that empty line is required due to an inner function starting immediately after.","title":"Empty lines"},{"location":"contribute/code_rules/#comments","text":"Black does not format comment contents, but it enforces two spaces between code and a comment on the same line, and a space before the comment text begins. Some types of comments that require specific spacing rules are respected: doc comments ( #: comment ), section comments with long runs of hashes, and Spyder cells. Non-breaking spaces after hashes are also preserved. Comments may sometimes be moved because of formatting changes, which can break tools that assign special meaning to them. See AST before and after formatting for more discussion.","title":"Comments"},{"location":"contribute/code_rules/#trailing-commas","text":"Black will add trailing commas to expressions that are split by comma where each element is on its own line. This includes function signatures. One exception to adding trailing commas is function signatures containing * , *args , or **kwargs . In this case a trailing comma is only safe to use on Python 3.6. Black will detect if your file is already 3.6+ only and use trailing commas in this situation. If you wonder how it knows, it looks for f-strings and existing use of trailing commas in function signatures that have stars in them. In other words, if you'd like a trailing comma in this situation and Black didn't recognize it was safe to do so, put it there manually and Black will keep it. A pre-existing trailing comma informs Black to always explode contents of the current bracket pair into one item per line. Read more about this in the Pragmatism section below. (labels/strings)=","title":"Trailing commas"},{"location":"contribute/code_rules/#strings","text":"Black prefers double quotes ( \" and \"\"\" ) over single quotes ( ' and ''' ). It will replace the latter with the former as long as it does not result in more backslash escapes than before. Black also standardizes string prefixes. Prefix characters are made lowercase with the exception of capital \"R\" prefixes , unicode literal markers ( u ) are removed because they are meaningless in Python 3, and in the case of multiple characters \"r\" is put first as in spoken language: \"raw f-string\". The main reason to standardize on a single form of quotes is aesthetics. Having one kind of quotes everywhere reduces reader distraction. It will also enable a future version of Black to merge consecutive string literals that ended up on the same line (see #26 for details). Why settle on double quotes? They anticipate apostrophes in English text. They match the docstring standard described in PEP 257 . An empty string in double quotes ( \"\" ) is impossible to confuse with a one double-quote regardless of fonts and syntax highlighting used. On top of this, double quotes for strings are consistent with C which Python interacts a lot with. On certain keyboard layouts like US English, typing single quotes is a bit easier than double quotes. The latter requires use of the Shift key. My recommendation here is to keep using whatever is faster to type and let Black handle the transformation. If you are adopting Black in a large project with pre-existing string conventions (like the popular \"single quotes for data, double quotes for human-readable strings\" ), you can pass --skip-string-normalization on the command line. This is meant as an adoption helper, avoid using this for new projects. Black also processes docstrings. Firstly the indentation of docstrings is corrected for both quotations and the text within, although relative indentation in the text is preserved. Superfluous trailing whitespace on each line and unnecessary new lines at the end of the docstring are removed. All leading tabs are converted to spaces, but tabs inside text are preserved. Whitespace leading and trailing one-line docstrings is removed.","title":"Strings"},{"location":"contribute/code_rules/#numeric-literals","text":"Black standardizes most numeric literals to use lowercase letters for the syntactic parts and uppercase letters for the digits themselves: 0xAB instead of 0XAB and 1e10 instead of 1E10 .","title":"Numeric literals"},{"location":"contribute/code_rules/#line-breaks-binary-operators","text":"Black will break a line before a binary operator when splitting a block of code over multiple lines. This is so that Black is compliant with the recent changes in the PEP 8 style guide, which emphasizes that this approach improves readability. Almost all operators will be surrounded by single spaces, the only exceptions are unary operators ( + , - , and ~ ), and power operators when both operands are simple. For powers, an operand is considered simple if it's only a NAME, numeric CONSTANT, or attribute access (chained attribute access is allowed), with or without a preceding unary operator. # For example, these won't be surrounded by whitespace a = x**y b = config.base**5.2 c = config.base**runtime.config.exponent d = 2**5 e = 2**~5 # ... but these will be surrounded by whitespace f = 2 ** get_exponent() g = get_x() ** get_y() h = config['base'] ** 2","title":"Line breaks &amp; binary operators"},{"location":"contribute/code_rules/#slices","text":"PEP 8 recommends to treat : in slices as a binary operator with the lowest priority, and to leave an equal amount of space on either side, except if a parameter is omitted (e.g. ham[1 + 1 :] ). It recommends no spaces around : operators for \"simple expressions\" ( ham[lower:upper] ), and extra space for \"complex expressions\" ( ham[lower : upper + offset] ). Black treats anything more than variable names as \"complex\" ( ham[lower : upper + 1] ). It also states that for extended slices, both : operators have to have the same amount of spacing, except if a parameter is omitted ( ham[1 + 1 ::] ). Black enforces these rules consistently. This behaviour may raise E203 whitespace before ':' warnings in style guide enforcement tools like Flake8. Since E203 is not PEP 8 compliant, you should tell Flake8 to ignore these warnings.","title":"Slices"},{"location":"contribute/code_rules/#parentheses","text":"Some parentheses are optional in the Python grammar. Any expression can be wrapped in a pair of parentheses to form an atom. There are a few interesting cases: if (...): while (...): for (...) in (...): assert (...), (...) from X import (...) assignments like: target = (...) target: type = (...) some, *un, packing = (...) augmented += (...) In those cases, parentheses are removed when the entire statement fits in one line, or if the inner expression doesn't have any delimiters to further split on. If there is only a single delimiter and the expression starts or ends with a bracket, the parentheses can also be successfully omitted since the existing bracket pair will organize the expression neatly anyway. Otherwise, the parentheses are added. Please note that Black does not add or remove any additional nested parentheses that you might want to have for clarity or further code organization. For example those parentheses are not going to be removed: return not (this or that) decision = (maybe.this() and values > 0) or (maybe.that() and values < 0)","title":"Parentheses"},{"location":"contribute/code_rules/#call-chains","text":"Some popular APIs, like ORMs, use call chaining. This API style is known as a fluent interface . Black formats those by treating dots that follow a call or an indexing operation like a very low priority delimiter. It's easier to show the behavior than to explain it. Look at the example: def example(session): result = ( session.query(models.Customer.id) .filter( models.Customer.account_id == account_id, models.Customer.email == email_address, ) .order_by(models.Customer.id.asc()) .all() )","title":"Call chains"},{"location":"contribute/code_rules/#typing-stub-files","text":"PEP 484 describes the syntax for type hints in Python. One of the use cases for typing is providing type annotations for modules which cannot contain them directly (they might be written in C, or they might be third-party, or their implementation may be overly dynamic, and so on). To solve this, stub files with the .pyi file extension can be used to describe typing information for an external module. Those stub files omit the implementation of classes and functions they describe, instead they only contain the structure of the file (listing globals, functions, and classes with their members). The recommended code style for those files is more terse than PEP 8: prefer ... on the same line as the class/function signature; avoid vertical whitespace between consecutive module-level functions, names, or methods and fields within a single class; use a single blank line between top-level class definitions, or none if the classes are very small. Black enforces the above rules. There are additional guidelines for formatting .pyi file that are not enforced yet but might be in a future version of the formatter: prefer ... over pass ; avoid using string literals in type annotations, stub files support forward references natively (like Python 3.7 code with from __future__ import annotations ); use variable annotations instead of type comments, even for stubs that target older versions of Python.","title":"Typing stub files"},{"location":"contribute/code_rules/#line-endings","text":"Black will normalize line endings ( \\n or \\r\\n ) based on the first line ending of the file.","title":"Line endings"},{"location":"contribute/code_rules/#pragmatism","text":"Early versions of Black used to be absolutist in some respects. They took after its initial author. This was fine at the time as it made the implementation simpler and there were not many users anyway. Not many edge cases were reported. As a mature tool, Black does make some exceptions to rules it otherwise holds. This section documents what those exceptions are and why this is the case. (labels/magic-trailing-comma)=","title":"Pragmatism"},{"location":"contribute/code_rules/#the-magic-trailing-comma","text":"Black in general does not take existing formatting into account. However, there are cases where you put a short collection or function call in your code but you anticipate it will grow in the future. For example: TRANSLATIONS = { \"en_us\": \"English (US)\", \"pl_pl\": \"polski\", } Early versions of Black used to ruthlessly collapse those into one line (it fits!). Now, you can communicate that you don't want that by putting a trailing comma in the collection yourself. When you do, Black will know to always explode your collection into one item per line. How do you make it stop? Just delete that trailing comma and Black will collapse your collection into one line if it fits. If you must, you can recover the behaviour of early versions of Black with the option --skip-magic-trailing-comma / -C .","title":"The magic trailing comma"},{"location":"contribute/code_rules/#rstrings-and-rstrings","text":"Black normalizes string quotes as well as string prefixes, making them lowercase. One exception to this rule is r-strings. It turns out that the very popular MagicPython syntax highlighter, used by default by (among others) GitHub and Visual Studio Code, differentiates between r-strings and R-strings. The former are syntax highlighted as regular expressions while the latter are treated as true raw strings with no special semantics. (labels/ast-changes)=","title":"r\"strings\" and R\"strings\""},{"location":"contribute/code_rules/#ast-before-and-after-formatting","text":"When run with --safe (the default), Black checks that the code before and after is semantically equivalent. This check is done by comparing the AST of the source with the AST of the target. There are three limited cases in which the AST does differ: Black cleans up leading and trailing whitespace of docstrings, re-indenting them if needed. It's been one of the most popular user-reported features for the formatter to fix whitespace issues with docstrings. While the result is technically an AST difference, due to the various possibilities of forming docstrings, all real-world uses of docstrings that we're aware of sanitize indentation and leading/trailing whitespace anyway. Black manages optional parentheses for some statements. In the case of the del statement, presence of wrapping parentheses or lack of thereof changes the resulting AST but is semantically equivalent in the interpreter. Black might move comments around, which includes type comments. Those are part of the AST as of Python 3.8. While the tool implements a number of special cases for those comments, there is no guarantee they will remain where they were in the source. Note that this doesn't change runtime behavior of the source code. To put things in perspective, the code equivalence check is a feature of Black which other formatters don't implement at all. It is of crucial importance to us to ensure code behaves the way it did before it got reformatted. We treat this as a feature and there are no plans to relax this in the future. The exceptions enumerated above stem from either user feedback or implementation details of the tool. In each case we made due diligence to ensure that the AST divergence is of no practical consequence.","title":"AST before and after formatting"},{"location":"contribute/installation/","text":"Installation You want to contribute to this project ? :tada: You are more than welcome, but before you head-start, please read the few instructions below... OS supported Debian 10 Debian 11 Ubuntu 20.04 Ubuntu 22.04 Setup a virtual environment Python Virtual Environment is strongly suggested in order to avoid dependecy conflicts on your system. The poetry project is used for development. Tools to generate your doc are strongly advised except if you like to do this manually. This project use lazydoc to auto-generate markdown doc from DocString mkdocs to auto-generate html page from basic markdown structure and lazydoc output mkdocs-awesome-pages-plugin in order to have a beautiful theme :wink: Code Style This project use BLACK code rules as code style, please respect this. Adapt code exceptions If you are using vscode along with poetry you can find inside pyproject.toml some exclusion on Black style code. If you need to add some extras ones here is the Error codes. Install project Once your prerequises are met, you should then launch poetry and install dependencies cd /path/to/project poetry shell poetry install Test publication Add repository to poetry config poetry config repositories.test-pypi https://test.pypi.org/legacy/ Get token from https://test.pypi.org/manage/account/token/ store token poetry config pypi-token.test-pypi pypi-YYYYYYYY Each time you need to publish poetry publish -r test-pypi","title":"Installation"},{"location":"contribute/installation/#installation","text":"You want to contribute to this project ? :tada: You are more than welcome, but before you head-start, please read the few instructions below...","title":"Installation"},{"location":"contribute/installation/#os-supported","text":"Debian 10 Debian 11 Ubuntu 20.04 Ubuntu 22.04","title":"OS supported"},{"location":"contribute/installation/#setup-a-virtual-environment","text":"Python Virtual Environment is strongly suggested in order to avoid dependecy conflicts on your system. The poetry project is used for development. Tools to generate your doc are strongly advised except if you like to do this manually. This project use lazydoc to auto-generate markdown doc from DocString mkdocs to auto-generate html page from basic markdown structure and lazydoc output mkdocs-awesome-pages-plugin in order to have a beautiful theme :wink:","title":"Setup a virtual environment"},{"location":"contribute/installation/#code-style","text":"This project use BLACK code rules as code style, please respect this.","title":"Code Style"},{"location":"contribute/installation/#adapt-code-exceptions","text":"If you are using vscode along with poetry you can find inside pyproject.toml some exclusion on Black style code. If you need to add some extras ones here is the Error codes.","title":"Adapt code exceptions"},{"location":"contribute/installation/#install-project","text":"Once your prerequises are met, you should then launch poetry and install dependencies cd /path/to/project poetry shell poetry install","title":"Install project"},{"location":"contribute/installation/#test-publication","text":"Add repository to poetry config poetry config repositories.test-pypi https://test.pypi.org/legacy/ Get token from https://test.pypi.org/manage/account/token/ store token poetry config pypi-token.test-pypi pypi-YYYYYYYY Each time you need to publish poetry publish -r test-pypi","title":"Test publication"},{"location":"contribute/poetry/","text":"Poetry cheat-sheet The Poetry project setup python virtual environment that jail dependencies of each project so it does not impact your host system. Create a new project poetry new <project-name> Add a new lib poetry add <library> Add a new lib for development purpose poetry add <library> -G dev Remove a lib poetry remove <library> Update a lib poetry update <library> Add a new development lib poetry add -G dev <library> Get venv path poetry run which python Run app poetry run python app.py Run tests poetry run python -m unittest discover Show dependencies poetry show Disable virtual environment creation poetry config virtualenvs.create false List configuratiom poetry config --list Configure your editor Set lint to pylint ...","title":"Poetry cheat-sheet"},{"location":"contribute/poetry/#poetry-cheat-sheet","text":"The Poetry project setup python virtual environment that jail dependencies of each project so it does not impact your host system.","title":"Poetry cheat-sheet"},{"location":"contribute/poetry/#create-a-new-project","text":"poetry new <project-name>","title":"Create a new project"},{"location":"contribute/poetry/#add-a-new-lib","text":"poetry add <library>","title":"Add a new lib"},{"location":"contribute/poetry/#add-a-new-lib-for-development-purpose","text":"poetry add <library> -G dev","title":"Add a new lib for development purpose"},{"location":"contribute/poetry/#remove-a-lib","text":"poetry remove <library>","title":"Remove a lib"},{"location":"contribute/poetry/#update-a-lib","text":"poetry update <library>","title":"Update a lib"},{"location":"contribute/poetry/#add-a-new-development-lib","text":"poetry add -G dev <library>","title":"Add a new development lib"},{"location":"contribute/poetry/#get-venv-path","text":"poetry run which python","title":"Get venv path"},{"location":"contribute/poetry/#run-app","text":"poetry run python app.py","title":"Run app"},{"location":"contribute/poetry/#run-tests","text":"poetry run python -m unittest discover","title":"Run tests"},{"location":"contribute/poetry/#show-dependencies","text":"poetry show","title":"Show dependencies"},{"location":"contribute/poetry/#disable-virtual-environment-creation","text":"poetry config virtualenvs.create false","title":"Disable virtual environment creation"},{"location":"contribute/poetry/#list-configuratiom","text":"poetry config --list","title":"List configuratiom"},{"location":"contribute/poetry/#configure-your-editor","text":"Set lint to pylint ...","title":"Configure your editor"},{"location":"contribute/prerequise/","text":"Prerequise SysPlant does not need any kind of preinstallation to run other than python3 installed on the system. Python3 on Debian based systems On Debian-based linux systems (Debian / Ubuntu / Kali), installing python3 and pip3 is like apt install python3 python3-pip Python3 on Windows systems A complete guide can be found on python.ord or more detailed on phoenixap.com 1. Download python installer 2. Ensure pip is installed pip -V Poetry installation This project works using poetry as a python venv. You could install it using then online doc or: For Linux, macOS or Windows (WSL) curl -sSL https://install.python-poetry.org | python3 - For Windows (Powershell) (Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py - Note: If you have installed Python through the Microsoft Store, replace py with python in the command above.","title":"Prerequise"},{"location":"contribute/prerequise/#prerequise","text":"SysPlant does not need any kind of preinstallation to run other than python3 installed on the system.","title":"Prerequise"},{"location":"contribute/prerequise/#python3-on-debian-based-systems","text":"On Debian-based linux systems (Debian / Ubuntu / Kali), installing python3 and pip3 is like apt install python3 python3-pip","title":"Python3 on Debian based systems"},{"location":"contribute/prerequise/#python3-on-windows-systems","text":"A complete guide can be found on python.ord or more detailed on phoenixap.com 1. Download python installer 2. Ensure pip is installed pip -V","title":"Python3 on Windows systems"},{"location":"contribute/prerequise/#poetry-installation","text":"This project works using poetry as a python venv. You could install it using then online doc or:","title":"Poetry installation"},{"location":"contribute/prerequise/#for-linux-macos-or-windows-wsl","text":"curl -sSL https://install.python-poetry.org | python3 -","title":"For Linux, macOS or Windows (WSL)"},{"location":"contribute/prerequise/#for-windows-powershell","text":"(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py - Note: If you have installed Python through the Microsoft Store, replace py with python in the command above.","title":"For Windows (Powershell)"},{"location":"contribute/tests/","text":"Tests This application should be used as a dependency from other projects. Development has been made using poetry, so you should have it installed. In case you really do not want to use poetry, you coul run test using pytest Commands While using poetry framework you could simply run poetry run pytest If you do not want to use poetry you can run python3 -m pytest Behaviour If everything is right you should generate 1 single file syscall.nim using the default command line: ./main.py Some samples files are stored in examples-output so you can compare them with your results. Documentation This project use mkdocs associated with lazydocs to auto-generate documentation. Write your Doc-String by using AutoDocString in VSCode Generate the project documentation using LazyDoc export PYTHONPATH=$PWD; lazydocs --output-path=\"./docs/documentation\" --overview-file=\"README.md\" --src-base-url=\"https://github.com/x42en/sysplant/blob/master\" sysplant/ Serving local docs for preview using mkdocs mkdocs serve","title":"Tests"},{"location":"contribute/tests/#tests","text":"This application should be used as a dependency from other projects. Development has been made using poetry, so you should have it installed. In case you really do not want to use poetry, you coul run test using pytest","title":"Tests"},{"location":"contribute/tests/#commands","text":"While using poetry framework you could simply run poetry run pytest If you do not want to use poetry you can run python3 -m pytest","title":"Commands"},{"location":"contribute/tests/#behaviour","text":"If everything is right you should generate 1 single file syscall.nim using the default command line: ./main.py Some samples files are stored in examples-output so you can compare them with your results.","title":"Behaviour"},{"location":"contribute/tests/#documentation","text":"This project use mkdocs associated with lazydocs to auto-generate documentation. Write your Doc-String by using AutoDocString in VSCode Generate the project documentation using LazyDoc export PYTHONPATH=$PWD; lazydocs --output-path=\"./docs/documentation\" --overview-file=\"README.md\" --src-base-url=\"https://github.com/x42en/sysplant/blob/master\" sysplant/ Serving local docs for preview using mkdocs mkdocs serve","title":"Documentation"},{"location":"documentation/","text":"API Overview Modules abstracts abstracts.abstractFactory abstracts.abstractGenerator constants constants.sysplantConstants data managers managers.cGenerator managers.nimGenerator managers.templateManager sysplant templates templates.iterators templates.resolvers templates.stubs utils utils.loggerSingleton utils.singleton Classes abstractFactory.AbstractFactory : Public Abstract factory class handling standard methods used by child instances abstractGenerator.AbstractGenerator : Public generator class handling standard methods used by child instances sysplantConstants.SysPlantConstants : Simple class storing constants for SysPlant app. cGenerator.CGenerator : Main class responsible for C code generation nimGenerator.NIMGenerator : Main class responsible for NIM code generation templateManager.TemplateManager : Main class responsible for template handling: tag replacement or erase with content generated by __coder bot sysplant.Sysplant : Main Class handling the global function to execute. Nothing should be done to the data in here. loggerSingleton.LoggerSingleton : Simple class used to display messages on CLI. singleton.Singleton Functions No functions This file was automatically generated via lazydocs .","title":"Overview"},{"location":"documentation/#api-overview","text":"","title":"API Overview"},{"location":"documentation/#modules","text":"abstracts abstracts.abstractFactory abstracts.abstractGenerator constants constants.sysplantConstants data managers managers.cGenerator managers.nimGenerator managers.templateManager sysplant templates templates.iterators templates.resolvers templates.stubs utils utils.loggerSingleton utils.singleton","title":"Modules"},{"location":"documentation/#classes","text":"abstractFactory.AbstractFactory : Public Abstract factory class handling standard methods used by child instances abstractGenerator.AbstractGenerator : Public generator class handling standard methods used by child instances sysplantConstants.SysPlantConstants : Simple class storing constants for SysPlant app. cGenerator.CGenerator : Main class responsible for C code generation nimGenerator.NIMGenerator : Main class responsible for NIM code generation templateManager.TemplateManager : Main class responsible for template handling: tag replacement or erase with content generated by __coder bot sysplant.Sysplant : Main Class handling the global function to execute. Nothing should be done to the data in here. loggerSingleton.LoggerSingleton : Simple class used to display messages on CLI. singleton.Singleton","title":"Classes"},{"location":"documentation/#functions","text":"No functions This file was automatically generated via lazydocs .","title":"Functions"},{"location":"documentation/abstracts.abstractFactory/","text":"module abstracts.abstractFactory class AbstractFactory Public Abstract factory class handling standard methods used by child instances method __init__ __init__() \u2192 None Init method. Register a self.data var containing the raw data that will be used for operations Setup a Logger singleton to self.logger shared var usable by child clases method generate_random_seed generate_random_seed() \u2192 int Public method used to generate a random int used as seed Range from: 2^28 to (2^32 - 1) Returns: int : The generated random seed method generate_random_string generate_random_string( length: int, choices: list = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ) \u2192 str Public method used to generate a random string Args: length (int): The random string length to generate choices (list, optional): The chars space used for generation. Defaults to string.ascii_letters. Returns: str : The generated random string method get_function_hash get_function_hash(seed: int, name: str) \u2192 int Public method used to hash kernel call to evade with random hex number in order to avoid static analysis detection. Args: name (str): The kernel call to evade Returns: int : The kernel call hashed method remove_tag remove_tag(name: str) \u2192 None Public method used to remove a TAG pattern in self.data var (dropping the line for clean code at the same time) Args: name (str): the tag name to remove method replace_tag replace_tag(name: str, content: str) \u2192 None Public method used to replace a TAG pattern in data var with content Args: name (str): the tag name to replace content (str): the content value to replace tag with This file was automatically generated via lazydocs .","title":"abstracts.abstractFactory"},{"location":"documentation/abstracts.abstractFactory/#module-abstractsabstractfactory","text":"","title":"module abstracts.abstractFactory"},{"location":"documentation/abstracts.abstractFactory/#class-abstractfactory","text":"Public Abstract factory class handling standard methods used by child instances","title":"class AbstractFactory"},{"location":"documentation/abstracts.abstractFactory/#method-__init__","text":"__init__() \u2192 None Init method. Register a self.data var containing the raw data that will be used for operations Setup a Logger singleton to self.logger shared var usable by child clases","title":"method __init__"},{"location":"documentation/abstracts.abstractFactory/#method-generate_random_seed","text":"generate_random_seed() \u2192 int Public method used to generate a random int used as seed Range from: 2^28 to (2^32 - 1) Returns: int : The generated random seed","title":"method generate_random_seed"},{"location":"documentation/abstracts.abstractFactory/#method-generate_random_string","text":"generate_random_string( length: int, choices: list = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ) \u2192 str Public method used to generate a random string Args: length (int): The random string length to generate choices (list, optional): The chars space used for generation. Defaults to string.ascii_letters. Returns: str : The generated random string","title":"method generate_random_string"},{"location":"documentation/abstracts.abstractFactory/#method-get_function_hash","text":"get_function_hash(seed: int, name: str) \u2192 int Public method used to hash kernel call to evade with random hex number in order to avoid static analysis detection. Args: name (str): The kernel call to evade Returns: int : The kernel call hashed","title":"method get_function_hash"},{"location":"documentation/abstracts.abstractFactory/#method-remove_tag","text":"remove_tag(name: str) \u2192 None Public method used to remove a TAG pattern in self.data var (dropping the line for clean code at the same time) Args: name (str): the tag name to remove","title":"method remove_tag"},{"location":"documentation/abstracts.abstractFactory/#method-replace_tag","text":"replace_tag(name: str, content: str) \u2192 None Public method used to replace a TAG pattern in data var with content Args: name (str): the tag name to replace content (str): the content value to replace tag with This file was automatically generated via lazydocs .","title":"method replace_tag"},{"location":"documentation/abstracts.abstractGenerator/","text":"module abstracts.abstractGenerator class AbstractGenerator Public generator class handling standard methods used by child instances method __init__ __init__(log_level: int = 20) \u2192 None method generate_definitions generate_definitions() \u2192 str Public method used to generate all required definitions by hooked syscall. It will first loop through the required functions to hook, extract all parameters type to declare and call the private __generate_typedefs function to generate the associated code block. Once all chained it will return the complete code block to integrate in template Returns: str : NIM code for template integration method generate_enum generate_enum(name: str, definition: list) \u2192 str method generate_pointer generate_pointer(name: str, definition: list) \u2192 str method generate_seed generate_seed(name: str) \u2192 str method generate_standard generate_standard(name: str, definition: list) \u2192 str method generate_struct generate_struct(name: str, definition: list) \u2192 str method generate_stub generate_stub(name: str, params: dict, fhash: int) \u2192 str method generate_union generate_union(name: str, definition: list) \u2192 str method set_extra_definitions set_extra_definitions(name: str) \u2192 None This file was automatically generated via lazydocs .","title":"abstracts.abstractGenerator"},{"location":"documentation/abstracts.abstractGenerator/#module-abstractsabstractgenerator","text":"","title":"module abstracts.abstractGenerator"},{"location":"documentation/abstracts.abstractGenerator/#class-abstractgenerator","text":"Public generator class handling standard methods used by child instances","title":"class AbstractGenerator"},{"location":"documentation/abstracts.abstractGenerator/#method-__init__","text":"__init__(log_level: int = 20) \u2192 None","title":"method __init__"},{"location":"documentation/abstracts.abstractGenerator/#method-generate_definitions","text":"generate_definitions() \u2192 str Public method used to generate all required definitions by hooked syscall. It will first loop through the required functions to hook, extract all parameters type to declare and call the private __generate_typedefs function to generate the associated code block. Once all chained it will return the complete code block to integrate in template Returns: str : NIM code for template integration","title":"method generate_definitions"},{"location":"documentation/abstracts.abstractGenerator/#method-generate_enum","text":"generate_enum(name: str, definition: list) \u2192 str","title":"method generate_enum"},{"location":"documentation/abstracts.abstractGenerator/#method-generate_pointer","text":"generate_pointer(name: str, definition: list) \u2192 str","title":"method generate_pointer"},{"location":"documentation/abstracts.abstractGenerator/#method-generate_seed","text":"generate_seed(name: str) \u2192 str","title":"method generate_seed"},{"location":"documentation/abstracts.abstractGenerator/#method-generate_standard","text":"generate_standard(name: str, definition: list) \u2192 str","title":"method generate_standard"},{"location":"documentation/abstracts.abstractGenerator/#method-generate_struct","text":"generate_struct(name: str, definition: list) \u2192 str","title":"method generate_struct"},{"location":"documentation/abstracts.abstractGenerator/#method-generate_stub","text":"generate_stub(name: str, params: dict, fhash: int) \u2192 str","title":"method generate_stub"},{"location":"documentation/abstracts.abstractGenerator/#method-generate_union","text":"generate_union(name: str, definition: list) \u2192 str","title":"method generate_union"},{"location":"documentation/abstracts.abstractGenerator/#method-set_extra_definitions","text":"set_extra_definitions(name: str) \u2192 None This file was automatically generated via lazydocs .","title":"method set_extra_definitions"},{"location":"documentation/abstracts/","text":"module abstracts This file was automatically generated via lazydocs .","title":"Abstracts"},{"location":"documentation/abstracts/#module-abstracts","text":"This file was automatically generated via lazydocs .","title":"module abstracts"},{"location":"documentation/constants/","text":"module constants Global Variables DESC_HEADER FANCY_HEADER This file was automatically generated via lazydocs .","title":"Constants"},{"location":"documentation/constants/#module-constants","text":"","title":"module constants"},{"location":"documentation/constants/#global-variables","text":"DESC_HEADER FANCY_HEADER This file was automatically generated via lazydocs .","title":"Global Variables"},{"location":"documentation/constants.sysplantConstants/","text":"module constants.sysplantConstants class SysPlantConstants Simple class storing constants for SysPlant app. This file was automatically generated via lazydocs .","title":"constants.sysplantConstants"},{"location":"documentation/constants.sysplantConstants/#module-constantssysplantconstants","text":"","title":"module constants.sysplantConstants"},{"location":"documentation/constants.sysplantConstants/#class-sysplantconstants","text":"Simple class storing constants for SysPlant app. This file was automatically generated via lazydocs .","title":"class SysPlantConstants"},{"location":"documentation/data/","text":"module data This file was automatically generated via lazydocs .","title":"Data"},{"location":"documentation/data/#module-data","text":"This file was automatically generated via lazydocs .","title":"module data"},{"location":"documentation/managers.cGenerator/","text":"module managers.cGenerator class CGenerator Main class responsible for C code generation method __init__ __init__() \u2192 None method generate_debug generate_debug(debug: bool) \u2192 str Public method used to generate the SPT_DEBUG constant flag Args: debug (bool): Debug flag value Returns: str : C code for template integration method generate_definitions generate_definitions() \u2192 str method generate_enum generate_enum(name: str, definition: list) \u2192 str Public method used to generate C enum declaration. The enum structure will be generated as a public object for external code usages. A pointer to the enum structure will always be generated in the form of: P+NAME Args: name (str): Enum structure name definition (list): Enum structure entries from definitions.json Returns: str : C code for enum structure (except type keyword for definition chaining) method generate_pointer generate_pointer(name: str, definition: list) \u2192 str Public method used to generate C pointer to defined var The pointer will be geneerated as a public object for external code usages. Args: name (str): Pointer name definition (list): Type definition to point to from definitions.json Returns: str : C code for standard pointer declaration method generate_seed generate_seed(seed: int) \u2192 str Public method used to generate the SPT_SEED constant value Args: seed (int): Seed value Returns: str : C code for template integration method generate_standard generate_standard(name: str, definition: list) \u2192 str Public method used to generate C varaiable declaration. The variable will be generated as a public object for external code usages. A pointer to the variable will always be generated in the form of: P+NAME Args: name (str): Variable name definition (list): Variable type from definitions.json Returns: str : C code for variable definition (except type keyword for definition chaining) method generate_struct generate_struct(name: str, definition: list) \u2192 str Public method used to generate a C basic structure. The structure will be generated as a public object for external code usages. A pointer to the structure will always be generated in the form of: *P+NAME Args: name (str): Structure name definition (list): Structure parameters from definitions.json Returns: str : C code for basic structure definition (except type keyword for definition chaining) method generate_stub generate_stub(name: str, params: dict, fhash: int) \u2192 str Public method used to generate stub code of syscall to hook Args: name (str): NtFunction name to hook params (dict): Parameters of functions defined in prototypes.json fhash (int): NtFunction hash value used by ASM call Returns: str : C code for template integration method generate_union generate_union(name: str, definition: list) \u2192 str Public method used to generate C union structure when a parent needs it. This structure will be generated as a private object as it won't be directly accessed by external code. A pointer to the union structure will always be generated in the form of: *P+NAME Args: name (str): Union structure name definition (list): Union structure parameters from definitions.json Returns: str : C code for union structure definition (except type keyword for definition chaining) This file was automatically generated via lazydocs .","title":"managers.cGenerator"},{"location":"documentation/managers.cGenerator/#module-managerscgenerator","text":"","title":"module managers.cGenerator"},{"location":"documentation/managers.cGenerator/#class-cgenerator","text":"Main class responsible for C code generation","title":"class CGenerator"},{"location":"documentation/managers.cGenerator/#method-__init__","text":"__init__() \u2192 None","title":"method __init__"},{"location":"documentation/managers.cGenerator/#method-generate_debug","text":"generate_debug(debug: bool) \u2192 str Public method used to generate the SPT_DEBUG constant flag Args: debug (bool): Debug flag value Returns: str : C code for template integration","title":"method generate_debug"},{"location":"documentation/managers.cGenerator/#method-generate_definitions","text":"generate_definitions() \u2192 str","title":"method generate_definitions"},{"location":"documentation/managers.cGenerator/#method-generate_enum","text":"generate_enum(name: str, definition: list) \u2192 str Public method used to generate C enum declaration. The enum structure will be generated as a public object for external code usages. A pointer to the enum structure will always be generated in the form of: P+NAME Args: name (str): Enum structure name definition (list): Enum structure entries from definitions.json Returns: str : C code for enum structure (except type keyword for definition chaining)","title":"method generate_enum"},{"location":"documentation/managers.cGenerator/#method-generate_pointer","text":"generate_pointer(name: str, definition: list) \u2192 str Public method used to generate C pointer to defined var The pointer will be geneerated as a public object for external code usages. Args: name (str): Pointer name definition (list): Type definition to point to from definitions.json Returns: str : C code for standard pointer declaration","title":"method generate_pointer"},{"location":"documentation/managers.cGenerator/#method-generate_seed","text":"generate_seed(seed: int) \u2192 str Public method used to generate the SPT_SEED constant value Args: seed (int): Seed value Returns: str : C code for template integration","title":"method generate_seed"},{"location":"documentation/managers.cGenerator/#method-generate_standard","text":"generate_standard(name: str, definition: list) \u2192 str Public method used to generate C varaiable declaration. The variable will be generated as a public object for external code usages. A pointer to the variable will always be generated in the form of: P+NAME Args: name (str): Variable name definition (list): Variable type from definitions.json Returns: str : C code for variable definition (except type keyword for definition chaining)","title":"method generate_standard"},{"location":"documentation/managers.cGenerator/#method-generate_struct","text":"generate_struct(name: str, definition: list) \u2192 str Public method used to generate a C basic structure. The structure will be generated as a public object for external code usages. A pointer to the structure will always be generated in the form of: *P+NAME Args: name (str): Structure name definition (list): Structure parameters from definitions.json Returns: str : C code for basic structure definition (except type keyword for definition chaining)","title":"method generate_struct"},{"location":"documentation/managers.cGenerator/#method-generate_stub","text":"generate_stub(name: str, params: dict, fhash: int) \u2192 str Public method used to generate stub code of syscall to hook Args: name (str): NtFunction name to hook params (dict): Parameters of functions defined in prototypes.json fhash (int): NtFunction hash value used by ASM call Returns: str : C code for template integration","title":"method generate_stub"},{"location":"documentation/managers.cGenerator/#method-generate_union","text":"generate_union(name: str, definition: list) \u2192 str Public method used to generate C union structure when a parent needs it. This structure will be generated as a private object as it won't be directly accessed by external code. A pointer to the union structure will always be generated in the form of: *P+NAME Args: name (str): Union structure name definition (list): Union structure parameters from definitions.json Returns: str : C code for union structure definition (except type keyword for definition chaining) This file was automatically generated via lazydocs .","title":"method generate_union"},{"location":"documentation/managers/","text":"module managers This file was automatically generated via lazydocs .","title":"Managers"},{"location":"documentation/managers/#module-managers","text":"This file was automatically generated via lazydocs .","title":"module managers"},{"location":"documentation/managers.nimGenerator/","text":"module managers.nimGenerator class NIMGenerator Main class responsible for NIM code generation method __init__ __init__() \u2192 None method generate_debug generate_debug(debug: bool) \u2192 str Public method used to generate the SPT_DEBUG constant flag Args: debug (bool): Debug flag value Returns: str : NIM code for template integration method generate_enum generate_enum(name: str, definition: list) \u2192 str Public method used to generate NIM enum declaration. The enum structure will be generated as a public object for external code usages. A pointer to the enum structure will always be generated in the form of: P+NAME Args: name (str): Enum structure name definition (list): Enum structure entries from definitions.json Returns: str : NIM code for enum structure (except type keyword for definition chaining) method generate_pointer generate_pointer(name: str, definition: list) \u2192 str Public method used to generate NIM pointer to defined var The pointer will be geneerated as a public object for external code usages. Args: name (str): Pointer name definition (list): Type definition to point to from definitions.json Returns: str : NIM code for standard pointer declaration method generate_seed generate_seed(seed: int) \u2192 str Public method used to generate the SPT_SEED constant value Args: seed (int): Seed value Returns: str : NIM code for template integration method generate_standard generate_standard(name: str, definition: list) \u2192 str Public method used to generate NIM varaiable declaration. The variable will be generated as a public object for external code usages. A pointer to the variable will always be generated in the form of: P+NAME Args: name (str): Variable name definition (list): Variable type from definitions.json Returns: str : NIM code for variable definition (except type keyword for definition chaining) method generate_struct generate_struct(name: str, definition: list) \u2192 str Public method used to generate a NIM basic structure. The structure will be generated as a public object for external code usages. A pointer to the structure will always be generated in the form of: P+NAME Args: name (str): Structure name definition (list): Structure parameters from definitions.json Returns: str : NIM code for basic structure definition (except type keyword for definition chaining) method generate_stub generate_stub(name: str, params: dict, fhash: int) \u2192 str Public method used to generate stub code of syscall to hook Args: name (str): NtFunction name to hook params (dict): Parameters of functions defined in prototypes.json fhash (int): NtFunction hash value used by ASM call Returns: str : NIM code for template integration method generate_union generate_union(name: str, definition: list) \u2192 str Public method used to generate NIM union structure when a parent needs it. This structure will be generated as a private object as it won't be directly accessed by external code. A pointer to the union structure will always be generated in the form of: P+NAME Args: name (str): Union structure name definition (list): Union structure parameters from definitions.json Returns: str : NIM code for union structure definition (except type keyword for definition chaining) This file was automatically generated via lazydocs .","title":"managers.nimGenerator"},{"location":"documentation/managers.nimGenerator/#module-managersnimgenerator","text":"","title":"module managers.nimGenerator"},{"location":"documentation/managers.nimGenerator/#class-nimgenerator","text":"Main class responsible for NIM code generation","title":"class NIMGenerator"},{"location":"documentation/managers.nimGenerator/#method-__init__","text":"__init__() \u2192 None","title":"method __init__"},{"location":"documentation/managers.nimGenerator/#method-generate_debug","text":"generate_debug(debug: bool) \u2192 str Public method used to generate the SPT_DEBUG constant flag Args: debug (bool): Debug flag value Returns: str : NIM code for template integration","title":"method generate_debug"},{"location":"documentation/managers.nimGenerator/#method-generate_enum","text":"generate_enum(name: str, definition: list) \u2192 str Public method used to generate NIM enum declaration. The enum structure will be generated as a public object for external code usages. A pointer to the enum structure will always be generated in the form of: P+NAME Args: name (str): Enum structure name definition (list): Enum structure entries from definitions.json Returns: str : NIM code for enum structure (except type keyword for definition chaining)","title":"method generate_enum"},{"location":"documentation/managers.nimGenerator/#method-generate_pointer","text":"generate_pointer(name: str, definition: list) \u2192 str Public method used to generate NIM pointer to defined var The pointer will be geneerated as a public object for external code usages. Args: name (str): Pointer name definition (list): Type definition to point to from definitions.json Returns: str : NIM code for standard pointer declaration","title":"method generate_pointer"},{"location":"documentation/managers.nimGenerator/#method-generate_seed","text":"generate_seed(seed: int) \u2192 str Public method used to generate the SPT_SEED constant value Args: seed (int): Seed value Returns: str : NIM code for template integration","title":"method generate_seed"},{"location":"documentation/managers.nimGenerator/#method-generate_standard","text":"generate_standard(name: str, definition: list) \u2192 str Public method used to generate NIM varaiable declaration. The variable will be generated as a public object for external code usages. A pointer to the variable will always be generated in the form of: P+NAME Args: name (str): Variable name definition (list): Variable type from definitions.json Returns: str : NIM code for variable definition (except type keyword for definition chaining)","title":"method generate_standard"},{"location":"documentation/managers.nimGenerator/#method-generate_struct","text":"generate_struct(name: str, definition: list) \u2192 str Public method used to generate a NIM basic structure. The structure will be generated as a public object for external code usages. A pointer to the structure will always be generated in the form of: P+NAME Args: name (str): Structure name definition (list): Structure parameters from definitions.json Returns: str : NIM code for basic structure definition (except type keyword for definition chaining)","title":"method generate_struct"},{"location":"documentation/managers.nimGenerator/#method-generate_stub","text":"generate_stub(name: str, params: dict, fhash: int) \u2192 str Public method used to generate stub code of syscall to hook Args: name (str): NtFunction name to hook params (dict): Parameters of functions defined in prototypes.json fhash (int): NtFunction hash value used by ASM call Returns: str : NIM code for template integration","title":"method generate_stub"},{"location":"documentation/managers.nimGenerator/#method-generate_union","text":"generate_union(name: str, definition: list) \u2192 str Public method used to generate NIM union structure when a parent needs it. This structure will be generated as a private object as it won't be directly accessed by external code. A pointer to the union structure will always be generated in the form of: P+NAME Args: name (str): Union structure name definition (list): Union structure parameters from definitions.json Returns: str : NIM code for union structure definition (except type keyword for definition chaining) This file was automatically generated via lazydocs .","title":"method generate_union"},{"location":"documentation/managers.templateManager/","text":"module managers.templateManager class TemplateManager Main class responsible for template handling: tag replacement or erase with content generated by __coder bot Args: AbstractFactory ( type ): AbstractClass defining useful functions potentially reusable by other classes method __init__ __init__( arch: str = 'x64', syscall: str = 'syscall', language: str = 'nim' ) \u2192 None Init method. Will instanciate appropriate self.__coder var depending on the language selected responsible for code generation Args: arch (str, optional): Code architecture to generate. Defaults to \"x64\". syscall (str, optional): Syscall instruction to use. Defaults to \"syscall\". language (str, optional): Language type used by code generator. Defaults to \"nim\". Raises: NotImplementedError : Error raised when using unsupported architecture NotImplementedError : Error raised when using unsupported syscall instruction NotImplementedError : Error raised when using unsupported language SystemError : Error raised when unable to load protoypes.json SystemError : Error raised when unable to load base template for language specify method generate_stubs generate_stubs(names: list) \u2192 str Public method used to generate stubs for all the NtFunctions to hook. Once generated a call is made to self.__generate_definitions() for automated type definitions. Generated code is then used to replace the SPT_STUBS tag in template. Args: names (list): List of NtFunctions to hook Raises: NotImplementedError : Error raised if NtFunction is not supported Returns: str : Template content after modification method list_common_syscalls list_common_syscalls() \u2192 list Public method used to retrieve most common functions names defined in prototypes.json Returns: list : List of NtFunctions names method list_donut_syscalls list_donut_syscalls() \u2192 list Public method used to retrieve functions names defined in prototypes.json used by Donut project (stay tuned for HOMER project ... ;) ) Returns: list : List of NtFunctions names method list_supported_syscalls list_supported_syscalls() \u2192 list Public method used to retrieve all supported functions names defined in prototypes.json Returns: list : List of NtFunctions names method load_stub load_stub(name) \u2192 str Public method used to load stub pattern file from package Args: name ( type ): Stub name to use Raises: SystemError : Error raised if filename does not exists Returns: str : File content (text mode) method scramble scramble() \u2192 str Public method used to randomize fixed internal function names to avoid static analysis by EDR/AV. Note: The concept behind this method is to let another project randomize the NtFunctions names as Sysplant as no view of the code using it. Returns: str : Template content after modification method set_debug set_debug() \u2192 str Public method used to generate the language specific code of DEBUG flag definition. Is debug is not set it will erase the tag from template. The debug definition code is then used to replace the SPT_DEBUG tag in template. Returns: str : Template content after modification method set_iterator set_iterator(name: str) \u2192 str Public method used to retrieve the language specific code of Syscall retrieval iterator. The selected iterator is then used to replace the SPT_ITERATOR tag in template. Args: name (str): Iterator name to use Returns: str : Template content after modification method set_method set_method(name: str) \u2192 str method set_seed set_seed(seed: int = 0) \u2192 str Public method used to generate the language specific code of SEED value definition. The seed parameter is optional and if omitted it will be automatically generated with a random value. The seed definition code is then used to replace the SPT_SEED tag in template. Args: seed (int, optional): Seed value. Defaults to 0. Returns: str : Template content after modification This file was automatically generated via lazydocs .","title":"managers.templateManager"},{"location":"documentation/managers.templateManager/#module-managerstemplatemanager","text":"","title":"module managers.templateManager"},{"location":"documentation/managers.templateManager/#class-templatemanager","text":"Main class responsible for template handling: tag replacement or erase with content generated by __coder bot Args: AbstractFactory ( type ): AbstractClass defining useful functions potentially reusable by other classes","title":"class TemplateManager"},{"location":"documentation/managers.templateManager/#method-__init__","text":"__init__( arch: str = 'x64', syscall: str = 'syscall', language: str = 'nim' ) \u2192 None Init method. Will instanciate appropriate self.__coder var depending on the language selected responsible for code generation Args: arch (str, optional): Code architecture to generate. Defaults to \"x64\". syscall (str, optional): Syscall instruction to use. Defaults to \"syscall\". language (str, optional): Language type used by code generator. Defaults to \"nim\". Raises: NotImplementedError : Error raised when using unsupported architecture NotImplementedError : Error raised when using unsupported syscall instruction NotImplementedError : Error raised when using unsupported language SystemError : Error raised when unable to load protoypes.json SystemError : Error raised when unable to load base template for language specify","title":"method __init__"},{"location":"documentation/managers.templateManager/#method-generate_stubs","text":"generate_stubs(names: list) \u2192 str Public method used to generate stubs for all the NtFunctions to hook. Once generated a call is made to self.__generate_definitions() for automated type definitions. Generated code is then used to replace the SPT_STUBS tag in template. Args: names (list): List of NtFunctions to hook Raises: NotImplementedError : Error raised if NtFunction is not supported Returns: str : Template content after modification","title":"method generate_stubs"},{"location":"documentation/managers.templateManager/#method-list_common_syscalls","text":"list_common_syscalls() \u2192 list Public method used to retrieve most common functions names defined in prototypes.json Returns: list : List of NtFunctions names","title":"method list_common_syscalls"},{"location":"documentation/managers.templateManager/#method-list_donut_syscalls","text":"list_donut_syscalls() \u2192 list Public method used to retrieve functions names defined in prototypes.json used by Donut project (stay tuned for HOMER project ... ;) ) Returns: list : List of NtFunctions names","title":"method list_donut_syscalls"},{"location":"documentation/managers.templateManager/#method-list_supported_syscalls","text":"list_supported_syscalls() \u2192 list Public method used to retrieve all supported functions names defined in prototypes.json Returns: list : List of NtFunctions names","title":"method list_supported_syscalls"},{"location":"documentation/managers.templateManager/#method-load_stub","text":"load_stub(name) \u2192 str Public method used to load stub pattern file from package Args: name ( type ): Stub name to use Raises: SystemError : Error raised if filename does not exists Returns: str : File content (text mode)","title":"method load_stub"},{"location":"documentation/managers.templateManager/#method-scramble","text":"scramble() \u2192 str Public method used to randomize fixed internal function names to avoid static analysis by EDR/AV. Note: The concept behind this method is to let another project randomize the NtFunctions names as Sysplant as no view of the code using it. Returns: str : Template content after modification","title":"method scramble"},{"location":"documentation/managers.templateManager/#method-set_debug","text":"set_debug() \u2192 str Public method used to generate the language specific code of DEBUG flag definition. Is debug is not set it will erase the tag from template. The debug definition code is then used to replace the SPT_DEBUG tag in template. Returns: str : Template content after modification","title":"method set_debug"},{"location":"documentation/managers.templateManager/#method-set_iterator","text":"set_iterator(name: str) \u2192 str Public method used to retrieve the language specific code of Syscall retrieval iterator. The selected iterator is then used to replace the SPT_ITERATOR tag in template. Args: name (str): Iterator name to use Returns: str : Template content after modification","title":"method set_iterator"},{"location":"documentation/managers.templateManager/#method-set_method","text":"set_method(name: str) \u2192 str","title":"method set_method"},{"location":"documentation/managers.templateManager/#method-set_seed","text":"set_seed(seed: int = 0) \u2192 str Public method used to generate the language specific code of SEED value definition. The seed parameter is optional and if omitted it will be automatically generated with a random value. The seed definition code is then used to replace the SPT_SEED tag in template. Args: seed (int, optional): Seed value. Defaults to 0. Returns: str : Template content after modification This file was automatically generated via lazydocs .","title":"method set_seed"},{"location":"documentation/sysplant/","text":"module sysplant Global Variables utils constants data abstracts templates managers class Sysplant Main Class handling the global function to execute. Nothing should be done to the data in here. Check TemplateManager (self.__engine) for data generation and modifications. method __init__ __init__( arch: str = 'x64', syscall: str = 'syscall', language: str = 'nim' ) \u2192 None Init method. Will instanciate self.__engine private var used for template modifications Args: arch (str, optional): Code architecture to generate. Defaults to \"x64\". syscall (str, optional): Syscall instruction to used. Defaults to \"syscall\". language (str, optional): Language type for code generate. Defaults to \"nim\". method generate generate(iterator: str, method: str, syscalls: Union[str, list]) \u2192 str Public method defining the generation algorithm. This method does not touch any code directly. It should only call TemplateManager methods in specific order. Modifications are let to TemplateManager class. Args: iterator (str): Iterator name to use (hell, halo, tartarus, freshy, syswhispers, canterlot) method (str): Stub type to use (direct, indirect, random) syscalls (Union[str, list]): NtFunctions list names to hook, or preset name (all|common|donut) Raises: ValueError : description Returns: str : Template content after generation method list list(search_path: str) \u2192 set method output output(output_path: str) \u2192 str Public method used to write generated code to filename Args: output_path (str): Filename where to write generated code Returns: str : Template content method scramble scramble(scramble: bool) \u2192 str Public method used to randomize internal function names. Note: The concept behind this method is to let another project randomize the NtFunctions names as Sysplant as no view of the code using it. Args: scramble (bool): Randomize flag value Returns: str : Template content after modification This file was automatically generated via lazydocs .","title":"Sysplant"},{"location":"documentation/sysplant/#module-sysplant","text":"","title":"module sysplant"},{"location":"documentation/sysplant/#global-variables","text":"utils constants data abstracts templates managers","title":"Global Variables"},{"location":"documentation/sysplant/#class-sysplant","text":"Main Class handling the global function to execute. Nothing should be done to the data in here. Check TemplateManager (self.__engine) for data generation and modifications.","title":"class Sysplant"},{"location":"documentation/sysplant/#method-__init__","text":"__init__( arch: str = 'x64', syscall: str = 'syscall', language: str = 'nim' ) \u2192 None Init method. Will instanciate self.__engine private var used for template modifications Args: arch (str, optional): Code architecture to generate. Defaults to \"x64\". syscall (str, optional): Syscall instruction to used. Defaults to \"syscall\". language (str, optional): Language type for code generate. Defaults to \"nim\".","title":"method __init__"},{"location":"documentation/sysplant/#method-generate","text":"generate(iterator: str, method: str, syscalls: Union[str, list]) \u2192 str Public method defining the generation algorithm. This method does not touch any code directly. It should only call TemplateManager methods in specific order. Modifications are let to TemplateManager class. Args: iterator (str): Iterator name to use (hell, halo, tartarus, freshy, syswhispers, canterlot) method (str): Stub type to use (direct, indirect, random) syscalls (Union[str, list]): NtFunctions list names to hook, or preset name (all|common|donut) Raises: ValueError : description Returns: str : Template content after generation","title":"method generate"},{"location":"documentation/sysplant/#method-list","text":"list(search_path: str) \u2192 set","title":"method list"},{"location":"documentation/sysplant/#method-output","text":"output(output_path: str) \u2192 str Public method used to write generated code to filename Args: output_path (str): Filename where to write generated code Returns: str : Template content","title":"method output"},{"location":"documentation/sysplant/#method-scramble","text":"scramble(scramble: bool) \u2192 str Public method used to randomize internal function names. Note: The concept behind this method is to let another project randomize the NtFunctions names as Sysplant as no view of the code using it. Args: scramble (bool): Randomize flag value Returns: str : Template content after modification This file was automatically generated via lazydocs .","title":"method scramble"},{"location":"documentation/templates.iterators/","text":"module templates.iterators This file was automatically generated via lazydocs .","title":"Templates.iterators"},{"location":"documentation/templates.iterators/#module-templatesiterators","text":"This file was automatically generated via lazydocs .","title":"module templates.iterators"},{"location":"documentation/templates/","text":"module templates This file was automatically generated via lazydocs .","title":"Templates"},{"location":"documentation/templates/#module-templates","text":"This file was automatically generated via lazydocs .","title":"module templates"},{"location":"documentation/templates.resolvers/","text":"module templates.resolvers This file was automatically generated via lazydocs .","title":"Templates.resolvers"},{"location":"documentation/templates.resolvers/#module-templatesresolvers","text":"This file was automatically generated via lazydocs .","title":"module templates.resolvers"},{"location":"documentation/templates.stubs/","text":"module templates.stubs This file was automatically generated via lazydocs .","title":"Templates.stubs"},{"location":"documentation/templates.stubs/#module-templatesstubs","text":"This file was automatically generated via lazydocs .","title":"module templates.stubs"},{"location":"documentation/utils.loggerSingleton/","text":"module utils.loggerSingleton class LoggerSingleton Simple class used to display messages on CLI. Using as a singleton so it will share the log_level everywhere Args: metaclass ( type , optional): description . Defaults to Singleton. method __init__ __init__(log_level: int = 20) \u2192 None method critical critical(message: str, stripped: bool = False) \u2192 None Public method used to display critical message (Default: red and starting with '[!!] ') Args: message (str): the critical message to output stripped (bool, optional): strip the starting pattern '[!!] '. Defaults to False. method debug debug(message: str, stripped: bool = False) \u2192 None Public method used to display debug message (Default: cyan and starting with '[*] ') Args: message (str): the debug message to output stripped (bool, optional): strip the starting pattern '[*] '. Defaults to False. method error error(message: str, stripped: bool = False) \u2192 None Public method used to display error message (Default: red and starting with '[!] ') Args: message (str): the error message to output stripped (bool, optional): strip the starting pattern '[!] '. Defaults to False. method info info(message: str, stripped: bool = False) \u2192 None Public method used to display info message (Default: green and starting with '[+] ') Args: message (str): the info message to output stripped (bool, optional): strip the starting pattern '[+] '. Defaults to False. method isDebug isDebug() \u2192 bool Public method used to detect debug conditions Returns: bool : debug state method output output(message: str) \u2192 None Public method used to display raw message without conditions or color Args: message (str): mesasge to display method warning warning(message: str, stripped: bool = False) \u2192 None Public method used to display warning message (Default: yellow and starting with '[!] ') Args: message (str): the warning message to output stripped (bool, optional): strip the starting pattern '[!] '. Defaults to False. This file was automatically generated via lazydocs .","title":"utils.loggerSingleton"},{"location":"documentation/utils.loggerSingleton/#module-utilsloggersingleton","text":"","title":"module utils.loggerSingleton"},{"location":"documentation/utils.loggerSingleton/#class-loggersingleton","text":"Simple class used to display messages on CLI. Using as a singleton so it will share the log_level everywhere Args: metaclass ( type , optional): description . Defaults to Singleton.","title":"class LoggerSingleton"},{"location":"documentation/utils.loggerSingleton/#method-__init__","text":"__init__(log_level: int = 20) \u2192 None","title":"method __init__"},{"location":"documentation/utils.loggerSingleton/#method-critical","text":"critical(message: str, stripped: bool = False) \u2192 None Public method used to display critical message (Default: red and starting with '[!!] ') Args: message (str): the critical message to output stripped (bool, optional): strip the starting pattern '[!!] '. Defaults to False.","title":"method critical"},{"location":"documentation/utils.loggerSingleton/#method-debug","text":"debug(message: str, stripped: bool = False) \u2192 None Public method used to display debug message (Default: cyan and starting with '[*] ') Args: message (str): the debug message to output stripped (bool, optional): strip the starting pattern '[*] '. Defaults to False.","title":"method debug"},{"location":"documentation/utils.loggerSingleton/#method-error","text":"error(message: str, stripped: bool = False) \u2192 None Public method used to display error message (Default: red and starting with '[!] ') Args: message (str): the error message to output stripped (bool, optional): strip the starting pattern '[!] '. Defaults to False.","title":"method error"},{"location":"documentation/utils.loggerSingleton/#method-info","text":"info(message: str, stripped: bool = False) \u2192 None Public method used to display info message (Default: green and starting with '[+] ') Args: message (str): the info message to output stripped (bool, optional): strip the starting pattern '[+] '. Defaults to False.","title":"method info"},{"location":"documentation/utils.loggerSingleton/#method-isdebug","text":"isDebug() \u2192 bool Public method used to detect debug conditions Returns: bool : debug state","title":"method isDebug"},{"location":"documentation/utils.loggerSingleton/#method-output","text":"output(message: str) \u2192 None Public method used to display raw message without conditions or color Args: message (str): mesasge to display","title":"method output"},{"location":"documentation/utils.loggerSingleton/#method-warning","text":"warning(message: str, stripped: bool = False) \u2192 None Public method used to display warning message (Default: yellow and starting with '[!] ') Args: message (str): the warning message to output stripped (bool, optional): strip the starting pattern '[!] '. Defaults to False. This file was automatically generated via lazydocs .","title":"method warning"},{"location":"documentation/utils/","text":"module utils This file was automatically generated via lazydocs .","title":"Utils"},{"location":"documentation/utils/#module-utils","text":"This file was automatically generated via lazydocs .","title":"module utils"},{"location":"documentation/utils.singleton/","text":"module utils.singleton class Singleton This file was automatically generated via lazydocs .","title":"Utils.singleton"},{"location":"documentation/utils.singleton/#module-utilssingleton","text":"","title":"module utils.singleton"},{"location":"documentation/utils.singleton/#class-singleton","text":"This file was automatically generated via lazydocs .","title":"class Singleton"},{"location":"install/installation/","text":"Installation Here are all the steps needed to install sysplant project. For more informations on how to use it see: usage Install it as dependency pip3 install sysplant Install it as tool On Linux, MacOS based systems git clone https://github.com/x42en/sysplant cd sysplant python3 ./main.py -h On Windows based systems C:\\> git clone https://github.com/x42en/sysplant.git C:\\> cd sysplant C:\\> python .\\main.py --help","title":"Installation"},{"location":"install/installation/#installation","text":"Here are all the steps needed to install sysplant project. For more informations on how to use it see: usage","title":"Installation"},{"location":"install/installation/#install-it-as-dependency","text":"pip3 install sysplant","title":"Install it as dependency"},{"location":"install/installation/#install-it-as-tool","text":"On Linux, MacOS based systems git clone https://github.com/x42en/sysplant cd sysplant python3 ./main.py -h On Windows based systems C:\\> git clone https://github.com/x42en/sysplant.git C:\\> cd sysplant C:\\> python .\\main.py --help","title":"Install it as tool"},{"location":"install/prerequise/","text":"Prerequise This project does not need any extra-lib, so except for the python3 presence nothing is required to run it.","title":"Prerequise"},{"location":"install/prerequise/#prerequise","text":"This project does not need any extra-lib, so except for the python3 presence nothing is required to run it.","title":"Prerequise"},{"location":"install/uninstall/","text":"Uninstall In order to remove the SysPlant project you can use the following procedure based on how you installed it at the first place Install it as dependencies pip3 remove sysplant Install it as tool rm -rf /path/to/sysplant","title":"Uninstall"},{"location":"install/uninstall/#uninstall","text":"In order to remove the SysPlant project you can use the following procedure based on how you installed it at the first place","title":"Uninstall"},{"location":"install/uninstall/#install-it-as-dependencies","text":"pip3 remove sysplant","title":"Install it as dependencies"},{"location":"install/uninstall/#install-it-as-tool","text":"rm -rf /path/to/sysplant","title":"Install it as tool"},{"location":"usage/cli/","text":"Using Sysplant as a CLI tool This project can be used as a simple command line tool. Installation Requirements: Pyton 3.8+ This is a python project that will generate NIM/C/etc... source code (bit weird hu ?! :grin:). So you can use it inside your python project as an external module or directly on your device as a tool. Install the project as you would do for any GitHub project. git clone https://github.com/x42en/sysplant && cd sysplant poetry shell ./main.py -h Usage This tool comes with various options that should be self-explanatory using the standard -h flag $ ./main.py -h usage: main.py [-h] [--debug | --verbose | --quiet] {list,generate} ... ..:: SysPlant - Your Syscall Factory ::.. positional arguments: {list,generate} optional arguments: -h, --help show this help message and exit Output options: --debug Display all DEBUG messages upon execution --verbose Display all INFO messages upon execution --quiet Remove all messages upon execution By now only two actions are supported list (that will parse file or directory to find NtFunction usage) and generate that will generate a syscall hooking file to import into your project List action In order to use the list action you could check the associated help ./main.py list -h $ ./main.py list -h usage: main.py list [-h] path positional arguments: path Path to search for NtFunction, could be a file or a directory optional arguments: -h, --help show this help message and exit Generate action In order to use the generate action you could check the associated help ./main.py generate -h $ ./main.py generate -h usage: main.py generate [-h] [-x86 | -wow | -x64] [-nim | -c] [-p {all,donut,common} | -f FUNCTIONS] [-x] -o OUTPUT {hell,halo,tartarus,freshy,syswhispers,syswhispers3,canterlot,custom} ... positional arguments: {hell,halo,tartarus,freshy,syswhispers,syswhispers3,canterlot,custom} optional arguments: -h, --help show this help message and exit -x, --scramble Randomize internal function names to evade static analysis -o OUTPUT, --output OUTPUT Output path for NIM generated file Architecture options: -x86 Set mode to 32bits -wow Set mode to WoW64 (execution of 32bits on 64bits) -x64 Set mode to 64bits (Default True) Language options: -nim Generate NIM code (Default: true) -c Generate C code Syscall options: -p {all,donut,common}, --preset {all,donut,common} Preset functions to generate (Default: common) -f FUNCTIONS, --functions FUNCTIONS Comma-separated functions Examples Here are some usage examples that will generate common NtFunctions only. This tool is not restricted to them, please READ THE DOC Hell's Gate generation $ ./main.py generate -o syscall hell Halo's Gate generation $ ./main.py generate -o syscall halo Tartarus's Gate generation $ ./main.py generate -o syscall tartarus FreshyCall generation $ ./main.py generate -o syscall freshy Syswhispers2 like generation $ ./main.py generate -o syscall syswhispers Syswhispers3 like generation $ ./main.py generate -o syscall syswhispers3 Canterlot's Gate generation $ ./main.py generate -o syscall canterlot Custom generation $ ./main.py generate -o syscall custom -i canterlot -m direct Generate C Code using Canterlot's Gate for Donut functions $ ./main.py generate -c -o syscall -p donut canterlot Real world Injection A simple example (launching calc.exe) is accessible using inject.nim . 1. Be sure to install winim library first: nimble install winim 2. Generate the syscall.nim file with ./main.py -o example/syscall.nim canterlot 3. Compile the injection template file with nim c -d=release -d=danger -d=strip --opt=size -d=mingw --app=console --cpu=amd64 --out=app.exe example/inject.nim on Linux (be sure to have mingw installed) 4. Copy the app.exe generated on your Windows device. Documentation The API documentation and associated options is available here Happy Hacking :beach: !","title":"Cli"},{"location":"usage/cli/#using-sysplant-as-a-cli-tool","text":"This project can be used as a simple command line tool.","title":"Using Sysplant as a CLI tool"},{"location":"usage/cli/#installation","text":"Requirements: Pyton 3.8+ This is a python project that will generate NIM/C/etc... source code (bit weird hu ?! :grin:). So you can use it inside your python project as an external module or directly on your device as a tool. Install the project as you would do for any GitHub project. git clone https://github.com/x42en/sysplant && cd sysplant poetry shell ./main.py -h","title":"Installation"},{"location":"usage/cli/#usage","text":"This tool comes with various options that should be self-explanatory using the standard -h flag $ ./main.py -h usage: main.py [-h] [--debug | --verbose | --quiet] {list,generate} ... ..:: SysPlant - Your Syscall Factory ::.. positional arguments: {list,generate} optional arguments: -h, --help show this help message and exit Output options: --debug Display all DEBUG messages upon execution --verbose Display all INFO messages upon execution --quiet Remove all messages upon execution By now only two actions are supported list (that will parse file or directory to find NtFunction usage) and generate that will generate a syscall hooking file to import into your project","title":"Usage"},{"location":"usage/cli/#list-action","text":"In order to use the list action you could check the associated help ./main.py list -h $ ./main.py list -h usage: main.py list [-h] path positional arguments: path Path to search for NtFunction, could be a file or a directory optional arguments: -h, --help show this help message and exit","title":"List action"},{"location":"usage/cli/#generate-action","text":"In order to use the generate action you could check the associated help ./main.py generate -h $ ./main.py generate -h usage: main.py generate [-h] [-x86 | -wow | -x64] [-nim | -c] [-p {all,donut,common} | -f FUNCTIONS] [-x] -o OUTPUT {hell,halo,tartarus,freshy,syswhispers,syswhispers3,canterlot,custom} ... positional arguments: {hell,halo,tartarus,freshy,syswhispers,syswhispers3,canterlot,custom} optional arguments: -h, --help show this help message and exit -x, --scramble Randomize internal function names to evade static analysis -o OUTPUT, --output OUTPUT Output path for NIM generated file Architecture options: -x86 Set mode to 32bits -wow Set mode to WoW64 (execution of 32bits on 64bits) -x64 Set mode to 64bits (Default True) Language options: -nim Generate NIM code (Default: true) -c Generate C code Syscall options: -p {all,donut,common}, --preset {all,donut,common} Preset functions to generate (Default: common) -f FUNCTIONS, --functions FUNCTIONS Comma-separated functions","title":"Generate action"},{"location":"usage/cli/#examples","text":"Here are some usage examples that will generate common NtFunctions only. This tool is not restricted to them, please READ THE DOC","title":"Examples"},{"location":"usage/cli/#hells-gate-generation","text":"$ ./main.py generate -o syscall hell","title":"Hell's Gate generation"},{"location":"usage/cli/#halos-gate-generation","text":"$ ./main.py generate -o syscall halo","title":"Halo's Gate generation"},{"location":"usage/cli/#tartaruss-gate-generation","text":"$ ./main.py generate -o syscall tartarus","title":"Tartarus's Gate generation"},{"location":"usage/cli/#freshycall-generation","text":"$ ./main.py generate -o syscall freshy","title":"FreshyCall generation"},{"location":"usage/cli/#syswhispers2-like-generation","text":"$ ./main.py generate -o syscall syswhispers","title":"Syswhispers2 like generation"},{"location":"usage/cli/#syswhispers3-like-generation","text":"$ ./main.py generate -o syscall syswhispers3","title":"Syswhispers3 like generation"},{"location":"usage/cli/#canterlots-gate-generation","text":"$ ./main.py generate -o syscall canterlot","title":"Canterlot's Gate generation"},{"location":"usage/cli/#custom-generation","text":"$ ./main.py generate -o syscall custom -i canterlot -m direct","title":"Custom generation"},{"location":"usage/cli/#generate-c-code-using-canterlots-gate-for-donut-functions","text":"$ ./main.py generate -c -o syscall -p donut canterlot","title":"Generate C Code using Canterlot's Gate for Donut functions"},{"location":"usage/cli/#real-world-injection","text":"A simple example (launching calc.exe) is accessible using inject.nim . 1. Be sure to install winim library first: nimble install winim 2. Generate the syscall.nim file with ./main.py -o example/syscall.nim canterlot 3. Compile the injection template file with nim c -d=release -d=danger -d=strip --opt=size -d=mingw --app=console --cpu=amd64 --out=app.exe example/inject.nim on Linux (be sure to have mingw installed) 4. Copy the app.exe generated on your Windows device.","title":"Real world Injection"},{"location":"usage/cli/#documentation","text":"The API documentation and associated options is available here Happy Hacking :beach: !","title":"Documentation"},{"location":"usage/lib/","text":"Using Sysplant as a Python Library This project has been designed so it can be embedded in your project as a simple external module. Installation If you are using standard pip3 package manager pip3 install sysplant If you are more likely to use virtual environments (you should!) this project is based on Poetry virtual env. poetry add sysplant Usage #!/usr/bin/env python3 # -*- coding:utf-8 -*- from sysplant import sysplant # Initialize the class bot = sysplant.Sysplant( arch=\"x64\", syscall=\"syscall\", language=\"nim\" ) # Generate code bot.generate( iterator=\"canterlot\", method=\"random\", syscalls=\"common\" ) # Optionally randomize internal names bot.scramble() # Generate file bot.output(\"/tmp/syscall\") Documentation A more precise documentation and associated options is available here","title":"Lib"},{"location":"usage/lib/#using-sysplant-as-a-python-library","text":"This project has been designed so it can be embedded in your project as a simple external module.","title":"Using Sysplant as a Python Library"},{"location":"usage/lib/#installation","text":"If you are using standard pip3 package manager pip3 install sysplant If you are more likely to use virtual environments (you should!) this project is based on Poetry virtual env. poetry add sysplant","title":"Installation"},{"location":"usage/lib/#usage","text":"#!/usr/bin/env python3 # -*- coding:utf-8 -*- from sysplant import sysplant # Initialize the class bot = sysplant.Sysplant( arch=\"x64\", syscall=\"syscall\", language=\"nim\" ) # Generate code bot.generate( iterator=\"canterlot\", method=\"random\", syscalls=\"common\" ) # Optionally randomize internal names bot.scramble() # Generate file bot.output(\"/tmp/syscall\")","title":"Usage"},{"location":"usage/lib/#documentation","text":"A more precise documentation and associated options is available here","title":"Documentation"}]}